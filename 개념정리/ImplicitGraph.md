# 암시적 그래프

**암시적 그래프(Implicit Graph)**는 명시적으로 노드와 간선을 저장하지 않고, 탐색하면서 그래프 구조를 동적으로 유추하는 방식
탐색 과정에서 이동 가능한 노드(정점)와 연결관계(간선)를 문제의 조건을 기반으로 판별

- “그래프를 그리지 않았지만 **탐색할 수 있는 모든 경우의 수가 노드**처럼 동작한다."
- 그리고 "**어떤 상태에서 이동할 수 있는 다른 상태들이 연결된 간선**처럼 동작한다."

`rowLength` = row 수(행 개수)는 grid의 크기

`colLength` = column 수(열 개수)는 첫 번째 행의 크기

## 인접리스트 없이 nextVertex 찾는 방법(암시적 그래프)

1. 현재 위치에서 상하좌우로 이동하여, 다음 노드(nextVertex)를 동적으로 찾는다.

2. 단순히 상하좌우를 탐색하다 보면 배열의 범위를 벗어나는 좌표가 발생할 수 있기 때문에 **범위를 벗어나는 경우를 제외**한다.

3. 모든 위치가 다음 노드가 될 수 없기 때문에 **이동 가능한지 유효성을 확인하는 것**이 필요하다.
   Valid 코드 (조건문으로 작성해도 무관함)

```java
public static boolean isValid(int r, int c){
	return 0 <= r && r < rowLength && 0 <= c && c < colLength;
}
```

```java
// 상하좌우 방향 벡터
int[] dr = {-1, 1, 0, 0}; // 위, 아래, 왼쪽, 오른쪽 (행 변화)
int[] dc = {0, 0, -1, 1}; // 위, 아래, 왼쪽, 오른쪽 (열 변화)

// 1. 상하좌우 4방향 탐색
for (int i = 0; i < 4; i++){
	nextRow = curRow + dr[i];
	nextCol = curCol + dc[i];
	// 2. 범위를 벗어나는 지 유효성 체크
	if(isValid(nextRow, nextCol)){
		// 방문 여부를 체크 & 3. 이동 가능한지를 체크
		if(!visited[nextRow][nextCol] && grid[nextRow][nextCol]  1){
			// bfs, dfs 탐색 선택
		}
	}
}
```

## 문제 유형

실제 알고리즘 수업에서 정말 많이 나온다!!
개념과 풀이방법을 제대로 알고 있도록 하자!

1. 미로 탐색
2. 퍼즐 이동
3. 격자에서 최단 경로 찾기

### 꼭 풀어볼 문제

1. 프로그래머스 - 미로 탈출
2. 백준 - 스타트 택시 (삼성 기출)
3. 프로그래머스 - 블록 이동하기 (카카오 기출)
